import {
    Assign, Binary, Call, Grouping, Literal, Logical, Unary, Variable, Expression, ExpressionVisitor
} from "../parser/expressions";
import {
    BlockStatement, CreateStatement, ExpressionStatement, FunctionStatement,
    IfStatement, OutputStatement, ReturnStatement, WhileStatement, Statement, StatementVisitor
} from "../parser/statements";
import { TokenType } from '../scanner/Token';

const INDENT_STRING = '  ';
const LET = 'let';

export class JavaScriptCompiler implements ExpressionVisitor<string>, StatementVisitor<string> {
    private indentLevel: number = 0;
    private outputParts: string[] = [];

    public compile(statements: Statement[] | null): string {
        this.outputParts = [];
        this.indentLevel = 0;

        if (!statements) {
            return "// Cannot compile due to parsing errors.";
        }

        const date = new Date().toDateString();
        const time = new Date().toLocaleTimeString();
        this.outputParts.push(`/** \n* Generated by Cosmo Compiler on ${date} at ${time}\n**/\n \n'use strict';\n\n`);
        
        try {
            for (const stmt of statements) {
                this.generateStmt(stmt);
            }
        } catch (error) {
            console.error("Code generation error:", error);
            return `// Error during code generation: ${error instanceof Error ? error.message : String(error)}`;
        }
        
        return this.outputParts.join('');
    }

    private indent(): string {
        return INDENT_STRING.repeat(this.indentLevel);
    }

    private generateStmt(stmt: Statement): void {
        this.outputParts.push(this.indent());
        this.outputParts.push(stmt.accept(this));
    }

    private generateExpr(expr: Expression): string {
        return expr.accept(this);
    }

    private generateBlockOrStmt(stmt: Statement): string {
        if (stmt instanceof BlockStatement) {
            return " " + stmt.accept(this);
        } else {
            let code = " {\n";
            this.indentLevel++;
            code += this.indent();
            code += stmt.accept(this);
            this.indentLevel--;
            code += this.indent() + "}\n";
            return code;
        }
    }

    public visitBlockStatement(statement: BlockStatement): string {
        let code = "{\n";
        this.indentLevel++;
        for (const innerStmt of statement.statements) {
            code += this.indent() + innerStmt.accept(this);
        }
        this.indentLevel--;
        code += this.indent() + "}\n";
        return code;
    }

    public visitCreateStatement(statement: CreateStatement): string {
        let code = `${LET} ${statement.name.lexeme}`;
        if (statement.initializer) {
            code += ` = ${this.generateExpr(statement.initializer)}`;
        } else {
            code += ` = null`;
        }
        return code + ";\n";
    }

    public visitExpressionStatement(statement: ExpressionStatement): string {
        return this.generateExpr(statement.expression) + ";\n";
    }

    public visitFunctionStatement(statement: FunctionStatement): string {
        const params = statement.params.map(p => p.lexeme).join(", ");
        let bodyCode = "{\n";
        this.indentLevel++;
        for (const bodyStmt of statement.body) {
            bodyCode += this.indent() + bodyStmt.accept(this);
        }
        this.indentLevel--;
        bodyCode += this.indent() + "}";
        return `function ${statement.name.lexeme}(${params}) ${bodyCode}\n`;
    }

    public visitIfStatement(statement: IfStatement): string {
        const conditionCode = this.generateExpr(statement.condition);
        const thenBranchCode = this.generateBlockOrStmt(statement.thenBranch);
        let code = `if (${conditionCode})${thenBranchCode}`;
        if (statement.elseBranch) {
            const elseBranchCode = this.generateBlockOrStmt(statement.elseBranch);
            code = code.trimEnd() + ` else${elseBranchCode}`;
        }
        return code;
    }

    public visitOutputStatement(statement: OutputStatement): string {
        return `console.log(${this.generateExpr(statement.expression)});\n`;
    }

    public visitReturnStatement(statement: ReturnStatement): string {
        if (statement.value) {
            return `return ${this.generateExpr(statement.value)};\n`;
        } else {
            return "return;\n";
        }
    }

    public visitWhileStatement(statement: WhileStatement): string {
        const conditionCode = this.generateExpr(statement.condition);
        const bodyCode = this.generateBlockOrStmt(statement.body);
        return `while (${conditionCode})${bodyCode}`;
    }

    public visitAssignExpression(expr: Assign): string {
        return `(${expr.name.lexeme} = ${this.generateExpr(expr.value)})`;
    }

    public visitBinaryExpression(expr: Binary): string {
        const left = this.generateExpr(expr.left);
        const right = this.generateExpr(expr.right);
        let op = expr.operator.lexeme;
        if (op === '==') op = '===';
        if (op === '!=') op = '!==';
        return `(${left} ${op} ${right})`;
    }

    public visitCallExpression(expr: Call): string {
        const calleeCode = this.generateExpr(expr.callee);
        const argsCode = expr.args.map(arg => this.generateExpr(arg)).join(", ");
        if (expr.callee instanceof Variable) {
            const calleeName = expr.callee.name.lexeme;
            switch (calleeName) {
                case 'add':
                    return `(${expr.args.map(arg => this.generateExpr(arg)).join(' + ')})`;
                case 'sqrt':
                    return `Math.sqrt(${argsCode})`;
                case 'clock':
                    return `(Date.now() / 1000.0)`;
                case 'random':
                    return `Math.random()`;
                case 'typeof':
                    return `typeof ${this.generateExpr(expr.args[0])}`;
                case 'substring':
                    return `${this.generateExpr(expr.args[0])}.substring(${this.generateExpr(expr.args[1])}, ${this.generateExpr(expr.args[2])})`;
                case 'length':
                    return `${this.generateExpr(expr.args[0])}.length`;
                case 'abs':
                    return `Math.abs(${this.generateExpr(expr.args[0])})`;
            }
        }
        return `${calleeCode}(${argsCode})`;
    }

    public visitGroupingExpression(expr: Grouping): string {
        return `(${this.generateExpr(expr.expression)})`;
    }

    public visitLiteralExpression(expr: Literal): string {
        const value = expr.value;
        if (typeof value === 'string') {
            return JSON.stringify(value);
        }
        if (value === null) {
            return "null";
        }
        return String(value);
    }

    public visitLogicalExpression(expr: Logical): string {
        const op = expr.operator.type === TokenType.OR ? '||' : '&&';
        return `(${this.generateExpr(expr.left)} ${op} ${this.generateExpr(expr.right)})`;
    }

    public visitUnaryExpression(expr: Unary): string {
        const operator = (expr.operator.type === TokenType.BANG || expr.operator.type === TokenType.NOT) ? '!' : '-';
        return `${operator}(${this.generateExpr(expr.right)})`;
    }

    public visitVariableExpression(expr: Variable): string {
        return expr.name.lexeme;
    }
}